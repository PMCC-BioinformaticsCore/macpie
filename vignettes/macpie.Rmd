---
title: "macpie"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 5
vignette: >
  %\VignetteIndexEntry{macpie}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, dpi=300}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Introduction

MAC-seq is a cost-effective, high-throughput transcriptomic platform,  developed as a collaboration betwee VCFG and MGC core facilities at PeterMac Cancer Centre, primarily designed for small molecule screening. However, its versatility extends beyond this application, thanks to its integration with high-throughput microscopy and 3D cell culturing techniques. 

<b>macpie</b> is a toolkit specifically developed for researchers working with MAC-seq data. Its primary aim is to deliver the latest tools for quality control (QC), visualization, and analysis. <b>macpie</b> is a result of a collaborative effort by a workgroup at the Peter MacCallum Cancer Centre (PeterMac), with a substantial support of the VCFG amd MGC core facilities.


MAC-seq data shares similarities with single-cell RNA-seq data as it derives gene counts from RNA sequences measured at the 3' ends of polyA transcripts. This results in sparse data, with many transcripts undetectable in individual samples, and a high throughput of transcriptomes analyzed per experiment. However, MAC-seq also parallels standard RNA-seq, as it typically includes replicate conditions and involves hundreds rather than thousands of samples per experiment, measured at higher depth.

<b>macpie</b> was designed to offer users a collection of best-practice analytical methods, drawing from both scRNA-seq and RNA-seq methodologies, while ensuring ease of use for non-experts.

### 1. Metadata import and QC

To ensure the integrity of metadata for future analyses, we provide the user with a set of tools to verify metadata consistency and visualize the key variables. Metadata has to be in a tabular format and contain the key columns for sample description as in the example dataset below.

**Key points**: 

  - use **plot_metadata_heatmap** to visually inspect metadata integrity

```{r load_metadata}
devtools::load_all()

library(macpie)
library(Seurat)
library(edgeR)
library(dplyr)
library(leidenbase)
library(gridExtra)
library(enrichR)
library(parallel)
library(mcprogress)
library(ggsci)
library(ggiraph)
library(pheatmap)
library(tidyr)
library(tibble)
library(enrichR)
library(variancePartition)
library(glmGamPoi)
library(PoiClaClu)
library(Matrix)


# Define project variables
project_name <- "PMMSq033"
project_metadata <- system.file("extdata/PMMSq033/PMMSq033_metadata_drugnames.csv", package = "macpie")

# Load metadata
metadata <- read_metadata(project_metadata)
metadata$Time <- as.factor(metadata$Time)
metadata$Concentration_1 <- as.factor(metadata$Concentration_1)
colnames(metadata)

# Validate metadata
validate_metadata(metadata)

```

First, let's visually inspect the large number of experimental variables, in order to correct artefacts and other metadata errors.

```{r metadata_plot, fig.width = 8, fig.height = 6}
plot_metadata_heatmap(metadata)


```

### 2. Sequencing data import and QC 

**Key points**: 

  -  pay special attention to removal of lowly expressed genes and then:
  -  use **plot_plate_layout** to check plate-level effects (edge vs centre, between plates)
  -  use **plot_mds** to check sample grouping (umap/pca is also available using Seurat's functions)
  -  use **compute_qc_metrics**, **plot_qc_metrics_heatmap**, and **plot_distance** to check sample variability
  -  use **plot_rle** to check any row/column effects and compare normalization methods

#### 2.1 Import data to tidySeurat object 

Data is imported into a tidySeurat object, which allows the usage of both the regular Seurat functions, as well as the functionality of tidyverse. 

```{r load_data}
# Import raw data
project_rawdata <- system.file("extdata/PMMSq033/raw_matrix", package = "macpie")
raw_counts_total <- Read10X(data.dir = project_rawdata)
keep <- rowSums(cpm(raw_counts_total) >= 10) >= 2 
raw_counts <- raw_counts_total[keep, ]

# Create tidySeurat object
mac <- CreateSeuratObject(counts = raw_counts,
                          project = project_name,
                          min.cells = 1,
                          min.features = 1)

# Join with metadata
mac <- mac %>%
  inner_join(metadata, by = c(".cell" = "Barcode"))

# Add unique identifier
mac <- mac %>%
  mutate(combined_id = str_c(Treatment_1, Concentration_1, sep = "_")) %>%
  mutate(combined_id = gsub(" ", "", .data$combined_id))

# Filter by read count per sample group
mac <- filter_genes_by_expression(mac, 
                                  group_by = "combined_id", 
                                  min_counts = 10, 
                                  min_samples = 2)
```
For example, we can use the common QC plots from the Seurat package to visualise the number of genes, reads, and percentage of mitochondrial and ribosomal genes per sample.
```{r violin_plot, fig.width = 8, fig.height = 4}
# Calculate percent of mitochondrial and ribosomal genes
mac[["percent.mt"]] <- PercentageFeatureSet(mac, pattern = "^mt-|^MT-")
mac[["percent.ribo"]] <- PercentageFeatureSet(mac, pattern = "^Rp[slp][[:digit:]]|^Rpsa|^RP[SLP][[:digit:]]|^RPSA")

# Example of a function from Seurat QC 
VlnPlot(mac, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo"), 
        ncol = 4, group.by = "Sample_type") & 
  scale_fill_manual(values = macpie_colours$discrete) 

```

In addition, we can use the power of tidyverse functions to further explore the dataset. For example, let's subset the Seurat object based on the column "Project" in metadata and visualise the grouping of data on the plate vs on an MDS plot. Plate layout plots are useful for visualising any spatial anomalies or unexpected patterns.

```{r subset_seurat, fig.width = 8, fig.height = 3}
unique(mac$Project)
mac <- mac %>%
  filter(Project == "Current")

# QC plot plate layout (all metadata columns can be used):
p <- plot_plate_layout(mac, "nCount_RNA", "combined_id")
girafe(ggobj = p, 
  fonts = list(sans = "sans"),
  options = list(
    opts_hover(css = "stroke:black; stroke-width:0.8px;")  # <- slight darkening
  ))
```


#### 2.2 Basic QC metrics

##### 2.2.1 Sample grouping with MDS plot


As a first step, we should visualise grouping of the samples based on top 500 expressed genes and limma's MDS function. As a warning, samples that are treated with a lower concentration of compound will often cluster close to the negative (vehicle) control. 

```{r mds_plot, fig.width = 8, fig.height = 6}
p <- plot_mds(mac, group_by = "Sample_type", label = "combined_id", n_labels = 30)
girafe(ggobj = p, fonts = list(sans = "sans"))

```

Since we are operating from a standard Seurat object, we can also use the standard scRNA-seq workflow. 

```{r qc_stats_umap, fig.width = 8, fig.height = 4}
mac <- SCTransform(mac) %>%
  RunPCA() %>%
  RunUMAP(dims = 1:30)
DimPlot(mac, reduction = "umap", group.by = "Sample_type", cols = macpie_colours$discrete)
```

##### 2.2.2 Distribution of read counts

We also want to expect what is the distribution of reads across the experiment. To that end we use box plot to show distribution of read counts grouped across treatments. Read count is commonly directly proportional to the number of cells.

```{r qc_stats_plot, fig.width = 8, fig.height = 4}
qc_stats <- compute_qc_metrics(mac, group_by = "combined_id", order_by = "median")
qc_stats$stats_summary
```
##### 2.2.3 Variability among all replicates

In relation to the previous plot, we want the user to have the ability to assess the dispersion of reads within a sample. Therefore, we enabled access to several statistical metrics such as standard deviation (sd_value), z score (z_score), mad (mad_value) and IQR (IQR) which can be used as a parameter to the function plot_qc_metrics individually, or assessed at once with the function plot_qc_metrics_heatmap. 

As you can see below, Staurosporine had the largest variability between the samples across all metrics. 

```{r qc_metrics, fig.width = 8, fig.height = 4}
plot_qc_metrics_heatmap(qc_stats$stats_summary)

```



##### 2.2.4 Variability within a sample

Due to the lower read counts per sample, MAC-seq is more variable than RNA-seq. It is therefore fairly important to estimate bioogical variability between the replicates. We provide a way to estimate inter-replicate variability using poisson distance within the function plot_distance.

```{r, fig.width = 8, fig.height = 6}
plot_distance(mac, "combined_id", treatment = "DMSO_0")
```

##### 2.2.5 Estimate of the batch effect

Several methods are available for scaling and normalizing transcriptomic data, with their effects most clearly visualized using RLE (Relative Log Expression) plots. In our case, limma_voom provides the lowest average coefficient of variation, when compared to other methods such as "raw", Seurat "SCT" or "edgeR".

```{r plot_rle, fig.width = 8, fig.height = 4}
# First we will subset the data to look at control, DMSO samples only
mac_dmso <- mac %>%
  filter(Treatment_1 == "DMSO")

# Run the RLE function
plot_rle(mac_dmso, label_column = "Row", normalisation = "limma_voom")

```


### 3. Differential gene expression

**Key points**: 

  -  use **compute_single_de** to perform a differential expression analysis for one treatment group vs control
  -  use **compute_multi_de** to perform differential expression analyses for all treatment groups vs control
  -  use volcano plot, box plot and heatmap to show results from the analyses and visualise gene expression levels  
  -  use **enrichr** for pathway enrichment analysis

#### 3.1. Single comparison

Similar to scRNA-seq data, MAC-seq gene expression counts have an excess of zero counts compared to bulk RNA-seq. Statistical models assuming a Poisson or negative binomial distribution may not fit the data well. For that reason, differential expression effects could be over or underestimated.

Let's first perform the differential expression analysis with a couple of methods and visualise
the results on a volcano plot.

```{r de_analysis, fig.width = 8, fig.height = 6}
# First perform the differential expression analysis
treatment_samples <- "Staurosporine_0.1"
control_samples <- "DMSO_0"
top_table <- compute_single_de(mac, treatment_samples, control_samples, method = "limma_voom")

# Let's visualise the results with a volcano plot
plot_volcano(top_table)

```

Based on the results, we can quickly check gene expression levels in counts per million (CPM) for selected genes between treatment and control samples as described below. 

```{r plot_cpm, fig.width = 8, fig.height = 6}
genes <- top_table$gene[1:6]
group_by <- "combined_id"
plot_cpm(mac,genes, group_by, treatment_samples, control_samples)
```

Some plotting functions also have a "summarise" version that provides collapsed versions of the results in a table format.

```{r de_single_summary}
summarise_de(top_table, lfc_threshold = 1, padj_threshold = 0.05)
```

#### 3.2. Pathway analysis

Differential gene expression results for individual comparisons of treatment vs control can be easily performed with functions from package <i>enrichR</i> and <i>fgsea</i>. In the following case, the effect of Staurosporine on breast cancer cells through Myc inactivation can be observed through pathway enrichment analyses. If you check the data from "DisGeNET", you will see that our mcf7 (breast cancer cell line) samples are correctly enriched for breast cancer profiles.

```{r pathway_analysis_single, fig.width = 8, fig.height = 4}
top_genes <- top_table %>%
  filter(p_value_adj < 0.05) %>%
  select(gene) %>%
  pull()

enriched <- enrichR::enrichr(top_genes, c("MSigDB_Hallmark_2020","DisGeNET",
                                 "RNA-Seq_Disease_Gene_and_Drug_Signatures_from_GEO"))
p1 <- enrichR::plotEnrich(enriched[[1]]) + 
  macpie_theme(legend_position_ = 'right') + 
  scale_fill_gradientn(colors = macpie_colours$divergent)

gridExtra::grid.arrange(p1, ncol = 1)

```

#### 3.3. Differential gene expression - multiple comparisons

Since MAC-seq is commonly used for high-throughput screening of compound libraries, we often want to compare multiple samples in a screen vs the control. This process can easily be parallelised. First we select a vector of "treatments" as combined_ids that do not contain the word "DMSO". (Warning, due to the limitations of "mclapply", parallelisation speedup currently only works on OSX and Linux machines, and not on Windows.)

```{r de_multi, fig.width = 8, fig.height = 5}
mac$combined_id <- make.names(mac$combined_id)

treatments <- mac %>%
  filter(Concentration_1 == 10) %>%
  select(combined_id) %>%
  filter(!grepl("DMSO", combined_id)) %>%
  pull() %>%
  unique()
mac <- compute_multi_de(mac, treatments, control_samples = "DMSO_0", method = "limma_voom", num_cores = 2)
```


We often want to ask which genes are differentially expressed in more than one treatment group. 

Here, we can visualise treatment groups with shared differentially expressed genes, defined as the top 5 DE genes from each single drug comparison (treatment vs control) that are found in at least 2 different treatment groups.

The heatmap below shows shared differentially expressed genes with corresponding log2FC values.

```{r plot_multi_de, fig.width=10, fig.height=6}
plot_multi_de(mac, group_by = "combined_id", value = "log2FC", p_value_cutoff = 0.01, direction="up", n_genes = 5, control = "DMSO_0", by="fc")
```
If you prefer to see the expression level on replicate level, you can specify logCPM = "lcpm". Since we are observing log CPM of individual samples, and not the comparisons, we can also visualise the DMSO control. 

```{r plot_multi_de_lcpm, fig.width=10, fig.height=6}
plot_multi_de(mac, group_by = "combined_id", value = "lcpm", p_value_cutoff = 0.01, direction="up", n_genes = 5, control = "DMSO_0", by="fc")
```

The outputs from the analyses above can be represented in table format.

```{r de_multi_summary}
summarise_de(mac, lfc_threshold = 1, padj_threshold = 0.01, multi=TRUE)
```

#### 3.4. Pathway analysis - multiple comparisons

The pathway enrichment analysis is done by using enrichR

Summarise the outputs from multi de comparison in a table

```{r enriched_pathways, fig.width = 8, fig.height = 12}

# Load genesets from enrichr for a specific species or define your own
enrichr_genesets <- download_geneset("human", "MSigDB_Hallmark_2020")
mac <- compute_multi_enrichr(mac, genesets = enrichr_genesets)

enriched_pathways_mat <- mac@tools$pathway_enrichment %>%
  bind_rows() %>%
  select(combined_id, Term, Combined.Score) %>%
  pivot_wider(names_from = combined_id, values_from = Combined.Score) %>%
  column_to_rownames(var = "Term") %>%
  mutate(across(everything(), ~ ifelse(is.na(.), 0, log1p(.)))) %>%  # Replace NA with 0 across all columns
  as.matrix()


pheatmap(enriched_pathways_mat, color = macpie_colours$continuous_rev)
```


**Quick check of some treatments**:

**Nutlin.3a** is a MDM2-P53 inhibitor and stablises the p53 protein. It induces cell autophagy and apotopsis. Nutlin-activated p53 induces G1 and G2 arrest in cancer cell lines (see in the pathway enrichment heatmap). 

**Ref**:
Tovar C, et al. Proc Natl Acad Sci USA. 2006;103(6):1888–1893.
Shows Nutlin-3’s effect on various p53 targets in cancer cell lines.



### 4. Methods for compound screening

**Key points**: 

  - use **compute_multi_screen_profile** to check gene set enrichment scores acorss all treatments given a gene list 
  
#### 4.1. Profile Similarity

```{r compute_multi_screen_profile, fig.width = 8, fig.height = 5}

mac <- compute_multi_screen_profile(mac, target = "Staurosporine_10", num_cores = 1)
mac_screen_profile <- mac@tools$screen_profile %>%
  mutate(logPadj = c(-log10(padj))) %>%
  arrange(desc(NES)) %>%
  mutate(target = factor(target, levels = unique(target))) 

ggplot(mac_screen_profile, aes(target, NES)) +
  #geom_point(aes(size = logPadj)) +
  geom_point() +
  facet_wrap(~pathway, scales = "free") +
  macpie_theme(x_labels_angle = 90, show_x_title = F)

```
Instead of plotting UMAP on individual samples, we can also visualise the samples on UMAP of differentials vs control.
```{r compute_de_umap, fig.width = 8, fig.height = 5}
mac <- compute_de_umap(mac)
mac <- find_clusters_de_umap(mac, k = 3)
p <- plot_de_umap(mac, group_by = "cluster", max_overlaps = 5)
girafe(ggobj = p, fonts = list(sans = "Open Sans"))
```


### 5. Multi-plates analysis

This section walks through QC and differential expression analysis of two MAC-seq plates with matched layouts.


**Key points**: 

  - import two macseq plates and check QC for any batch effects (and batch correction)
  - use **compute_single_de** and **compute_multi_de** by incorporating batch factor

#### 5.1 Import data and QC

Here we import the raw count matrix and metadata for the first plate, apply QC filters, and generate the tidySeurat object.

Load PMMSq033 and PMMSq034

```{r load_two_plates}
project_metadata <- system.file("extdata/PMMSq033/PMMSq033_metadata_drugnames.csv", package = "macpie")
metadata <- read_metadata(project_metadata)

pmm33_in <- system.file("extdata/PMMSq033/raw_matrix", package = "macpie")
pmm34_in <- system.file("extdata/PMMSq034/raw_matrix", package = "macpie")
raw_counts_total <- Read10X(data.dir = c(pmm33_in,pmm34_in))
keep <- rowSums(cpm(raw_counts_total) >= 10) >= 2
raw_counts <- raw_counts_total[keep, ]
combined <- CreateSeuratObject(counts=raw_counts,
                               min.cells = 1,
                          min.features = 1)

combined[["percent.mt"]] <- PercentageFeatureSet(combined, pattern = "^mt-|^MT-")
combined[["percent.ribo"]] <- PercentageFeatureSet(combined, pattern = "^Rp[slp][[:digit:]]|^Rpsa|^RP[SLP][[:digit:]]|^RPSA")

#join with metadata
combined$Barcode <- str_replace_all(rownames(combined@meta.data),"[1|2]_","")

combined <- combined %>%
  inner_join(metadata, by = c("Barcode" = "Barcode"))

combined <- combined%>%
  filter(Project == "Current")

#add unique identifier
combined <- combined %>%
  mutate(combined_id = str_c(Treatment_1, Concentration_1, sep = "_")) %>%
  mutate(combined_id = gsub(" ", "", .data$combined_id))

combined$combined_id <- make.names(combined$combined_id)

```

```{r}
# meta <- meta %>% mutate(Treatment_1 =  ifelse(grepl("^Ada|^Shenali|^EMPTY$", Treatment_1), Treatment_1, paste0("ML_", Treatment_1)))

combined <- combined %>% mutate(orig.ident = ifelse(grepl("1", orig.ident), "PMMSq033","PMMSq034"))
```


Plate layout for both plates:


```{r, fig.width = 10, fig.height = 4}
p <- plot_plate_layout(combined, "nCount_RNA", "combined_id") + facet_wrap(~orig.ident)
girafe(ggobj = p, 
  fonts = list(sans = "sans"),
  options = list(
    opts_hover(css = "stroke:black; stroke-width:1px;")
  ))

```



We visualize sample grouping across plates using MDS (multidimensional scaling) plots and assess expression variability using RLE plots.

```{r}
combined_dmso <- combined %>%
  filter(Treatment_1 == "DMSO")
```

```{r multi_plates_plot_mds, fig.width = 8, fig.height = 4}
plot_mds(combined, group_by = "orig.ident", label = "combined_id", n_labels = 30)
plot_mds(combined_dmso, group_by = "orig.ident", label = "combined_id", n_labels = 30)
```

RLE plots to show before and after using limma_voom for batch correction.  


```{r multi_plates_plot_rle, fig.width = 8, fig.height = 4}
plot_rle(combined_dmso, label_column = "orig.ident", normalisation = "raw") + scale_x_discrete(drop = FALSE) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
plot_rle(combined_dmso, label_column = "orig.ident", normalisation = "limma_voom") + scale_x_discrete(drop = FALSE) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

#### 5.2 Single comparison DE analysis 

We run differential expression using edgeR between one treatment condition and control (e.g. Staurosporine_0.1 vs DMSO_0), while accounting for plate effects via batch modeling.

First, we look at the volcano plot if no batch correction is used.

```{r multi_plates_compute_single_de_raw, fig.width = 8, fig.height = 6}
treatment_samples <- "Staurosporine_0.1"
control_samples <- "DMSO_0"
combined_lv_nobatch <- compute_single_de(combined, treatment_samples, control_samples, method =  "limma_voom")
plot_volcano(combined_lv_nobatch, max.overlaps = 10)

```

Then, we compare with the volcano plot after batch correction.


```{r multi_plates_compute_single_de, fig.width = 8, fig.height = 6}
treatment_samples <- "Staurosporine_0.1"
control_samples <- "DMSO_0"
subset <- combined[, grepl(paste0(treatment_samples, "|", control_samples), combined$combined_id)]
batch <- subset$orig.ident
combined_lv <- compute_single_de(combined, treatment_samples, control_samples, method = "limma_voom", batch = batch)
plot_volcano(combined_lv)

```

Check CPM levels for top 6 differentially expressed genes.

```{r multiplate_plot_cpm, fig.width = 8, fig.height = 6}
genes <- combined_lv$gene[1:6]
group_by <- "combined_id"
plot_cpm(combined,genes, group_by, treatment_samples, control_samples)

```

Summarise the outputs from single comparison in a table

```{r}
summarise_de(combined_lv, lfc_threshold = 1, padj_threshold = 0.01, multi=FALSE)
```

#### 5.3 Multi-comparison DE analysis 

We compare all treatment conditions against the DMSO control. This is especially useful for screening multiple drugs across the plates.

For visualisation purpose, we only use high concentration treatments in this workshop. 

```{r}
treatments <- combined %>%
  filter(Concentration_1 == 10) %>%
  select(combined_id) %>%
  filter(!grepl("DMSO", combined_id)) %>%
  pull() %>%
  unique()
combined <- compute_multi_de(combined, treatments, control_samples = "DMSO_0", method = "edgeR", num_cores = 2, batch = batch)
```

Summarise the outputs from single comparison in a table

```{r}
summarise_de(combined, lfc_threshold = 1, padj_threshold = 0.01, multi=TRUE)
```


Similar to single plate analysis, we can also use this heatmap shows shared differentially expressed genes with corresponding log2FC values.

```{r mutli_plates_plot_multi_de, fig.width=10, fig.height=6}
plot_multi_de(combined, group_by = "combined_id", value = "log2FC", p_value_cutoff = 0.01, direction="up", n_genes = 5, control = "DMSO_0", by="fc")

```
