---
title: "macpie"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 5
vignette: >
  %\VignetteIndexEntry{macpie}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Introduction

MAC-seq is a cost-effective, high-throughput transcriptomic platform,  developed as a collaboration betwee VCFG and MGC core facilities at PeterMac Cancer Centre, primarily designed for small molecule screening. However, its versatility extends beyond this application, thanks to its integration with high-throughput microscopy and 3D cell culturing techniques. 

<b>macpie</b> is a toolkit specifically developed for researchers working with MAC-seq data. Its primary aim is to deliver the latest tools for quality control (QC), visualization, and analysis. Macpie is a result of a collaborative effort by a workgroup at the Peter MacCallum Cancer Centre (PeterMac), with a substantial support of the VCFG amd MGC core facilities.


MAC-seq data shares similarities with single-cell RNA-seq data as it derives gene counts from RNA sequences measured at the 3' ends of polyA transcripts. This results in sparse data, with many transcripts undetectable in individual samples, and a high throughput of transcriptomes analyzed per experiment. However, MAC-seq also parallels standard RNA-seq, as it typically includes replicate conditions and involves hundreds rather than thousands of samples per experiment, measured at higher depth.

<b>macpie</b> was designed to offer users a collection of best-practice analytical methods, drawing from both scRNA-seq and RNA-seq methodologies, while ensuring ease of use for non-experts.

### 1. Metadata import and QC

To ensure the integrity of metadata for future analyses, we provide the user with a set of tools to verify metadata consistency and visualize the key variables. Metadata has to be in a tabular format and contain the key columns for sample description as in the example dataset below.

```{r load_metadata}

# Clean environment
rm(list = ls(all.names = TRUE)) # will clear all objects including hidden objects
gc() # free up memory and report the memory usage

# Load all functions
devtools::load_all()

library(macpie)
library(Seurat)
library(edgeR)
library(dplyr)
library(leidenbase)
library(gridExtra)
library(enrichR)
library(parallel)
library(mcprogress)
library(ggsci)
library(ggiraph)
library(pheatmap)
library(tidyr)
library(tibble)
library(enrichR)
library(variancePartition)
library(glmGamPoi)
library(PoiClaClu)


# Define project variables
project_name <- "PMMSq033"
project_metadata <- system.file("extdata/PMMSq033/PMMSq033_metadata_drugnames.csv", package = "macpie")

# Load metadata
metadata <- read_metadata(project_metadata)
metadata$Time <- as.factor(metadata$Time)
metadata$Concentration_1 <- as.factor(metadata$Concentration_1)
colnames(metadata)

# Validate metadata
validate_metadata(metadata)

```

First, let's visually inspect the large number of experimental variables, in order to correct artefacts and other metadata errors.

```{r metadata_plot, fig.width = 8, fig.height = 6}

plot_metadata_heatmap(metadata)


```

### 2. Sequencing data import and QC 
#### 2.1 Import data to tidySeurat object 

Data is imported into a tidySeurat object, which allows the usage of both the regular Seurat functions, as well as the functionality of tidyverse. 

```{r load_data}

project_rawdata <- system.file("extdata/PMMSq033/raw_matrix", package = "macpie")
raw_counts_total <- Read10X(data.dir = project_rawdata)
keep <- rowSums(cpm(raw_counts_total) >= 10) >= 2
raw_counts <- raw_counts_total[keep, ]

# Create tidySeurat object
mac <- CreateSeuratObject(counts = raw_counts,
                          project = project_name,
                          min.cells = 1,
                          min.features = 1)

```

```{r violin_plot, fig.width = 8, fig.height = 4}
# Calculate percent of mitochondrial and ribosomal genes
mac[["percent.mt"]] <- PercentageFeatureSet(mac, pattern = "^mt-|^MT-")
mac[["percent.ribo"]] <- PercentageFeatureSet(mac, pattern = "^Rp[slp][[:digit:]]|^Rpsa|^RP[SLP][[:digit:]]|^RPSA")

# Join with metadata
mac <- mac %>%
  inner_join(metadata, by = c(".cell" = "Barcode"))

# Add unique identifier
mac <- mac %>%
  mutate(combined_id = str_c(Treatment_1, Concentration_1, sep = "_")) %>%
  mutate(combined_id = gsub(" ", "", .data$combined_id))

# Example of a function from Seurat QC 
VlnPlot(mac, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo"), 
        ncol = 4, group.by = "Sample_type") & 
  scale_fill_manual(values = macpie_colours$discrete) 

```

This allows us to apply all of the tidyverse functions to manipulate the Seurat object.
For example, let's subset the Seurat object based on the column "Project" in metadata and visualise the grouping of data on the plate vs on an MDS plot.


```{r subset_seurat, fig.width = 8, fig.height = 5}
unique(mac$Project)
mac <- mac %>%
  filter(Project == "Current")
```



### 5. Multi-plates analysis

Now, we move on to analyse two plates with identical plate layout. This approach allows us to analyse samples across multiple plates. 

#### 5.1 QC



```{r}
# Define project variables
project_name <- "PMMSq033"
project_metadata <- system.file("extdata/PMMSq033/PMMSq033_metadata_drugnames.csv", package = "macpie")
metadata <- read_metadata(project_metadata)

project_rawdata <- system.file("extdata/PMMSq033/raw_matrix", package = "macpie")
raw_counts_total <- Read10X(data.dir = project_rawdata)
keep <- rowSums(cpm(raw_counts_total) >= 10) >= 2
raw_counts <- raw_counts_total[keep, ]

#create tidySeurat object
mac_pmm33 <- CreateSeuratObject(counts = raw_counts,
                          project = project_name,
                          min.cells = 1,
                          min.features = 1)
#calculate percent of mitochondrial and ribosomal genes
mac_pmm33[["percent.mt"]] <- PercentageFeatureSet(mac_pmm33, pattern = "^mt-|^MT-")
mac_pmm33[["percent.ribo"]] <- PercentageFeatureSet(mac_pmm33, pattern = "^Rp[slp][[:digit:]]|^Rpsa|^RP[SLP][[:digit:]]|^RPSA")

#join with metadata
mac_pmm33 <- mac_pmm33 %>%
  inner_join(metadata, by = c(".cell" = "Barcode"))

mac_pmm33 <- mac_pmm33%>%
  filter(Project == "Current")

#add unique identifier
mac_pmm33 <- mac_pmm33 %>%
  mutate(combined_id = str_c(Treatment_1, Concentration_1, sep = "_")) %>%
  mutate(combined_id = gsub(" ", "", .data$combined_id))

mac_pmm33$combined_id <- make.names(mac_pmm33$combined_id)
```



```{r load_data}
project_rawdata <- system.file("extdata/PMMSq034/raw_matrix", package = "macpie")
raw_counts_total <- Read10X(data.dir = project_rawdata)
keep <- rowSums(cpm(raw_counts_total) >= 10) >= 2
raw_counts <- raw_counts_total[keep, ]

#create tidySeurat object
project_name <- "PMMSq034"
mac_pmm34 <- CreateSeuratObject(counts = raw_counts,
                          project = project_name,
                          min.cells = 1,
                          min.features = 1)

#calculate percent of mitochondrial and ribosomal genes
mac_pmm34[["percent.mt"]] <- PercentageFeatureSet(mac_pmm34, pattern = "^mt-|^MT-")
mac_pmm34[["percent.ribo"]] <- PercentageFeatureSet(mac_pmm34, pattern = "^Rp[slp][[:digit:]]|^Rpsa|^RP[SLP][[:digit:]]|^RPSA")

#join with metadata
mac_pmm34 <- mac_pmm34 %>%
  inner_join(metadata, by = c(".cell" = "Barcode"))

mac_pmm34 <- mac_pmm34%>%
  filter(Project == "Current")

#add unique identifier
mac_pmm34 <- mac_pmm34 %>%
  mutate(combined_id = str_c(Treatment_1, Concentration_1, sep = "_")) %>%
  mutate(combined_id = gsub(" ", "", .data$combined_id))
mac_pmm34$combined_id <- make.names(mac_pmm34$combined_id)
```


```{r}

combined <- merge(mac_pmm33, mac_pmm34, add.cell.ids = c("PMMSq033", "PMMSq034"))

library(Matrix)

# 1. Get union of gene names
all_genes <- union(rownames(combined@assays$RNA$counts.PMMSq033),
                   rownames(combined@assays$RNA$counts.PMMSq034))

# 2. Define a helper to fill missing genes with 0s
pad_sparse_matrix <- function(mat, all_genes) {
  missing_genes <- setdiff(all_genes, rownames(mat))
  if (length(missing_genes) > 0) {
    # Create a zero matrix for missing genes
    zero_mat <- Matrix(0, nrow = length(missing_genes), ncol = ncol(mat), sparse = TRUE)
    rownames(zero_mat) <- missing_genes
    colnames(zero_mat) <- colnames(mat)
    
    # Combine existing and missing gene matrices
    mat <- rbind(mat, zero_mat)
  }
  
  # Reorder rows to match all_genes
  mat <- mat[all_genes, , drop = FALSE]
  return(mat)
}

# 3. Pad and align both matrices
counts1 <- pad_sparse_matrix(combined@assays$RNA$counts.PMMSq033, all_genes)
counts2 <- pad_sparse_matrix(combined@assays$RNA$counts.PMMSq034, all_genes)

# 4. Combine them safely
combined_counts <- cbind(counts1, counts2)
combined@assays$RNA$counts <- combined_counts
combined@assays$RNA$counts.PMMSq033 <- NULL
combined@assays$RNA$counts.PMMSq034 <- NULL


combined_dmso <- combined %>%
  filter(Treatment_1 == "DMSO")


```

```{r multi_plates_plot_mds, fig.width = 8, fig.height = 4}
plot_mds(combined, group_by = "orig.ident", label = "combined_id", n_labels = 30)
plot_mds(combined_dmso, group_by = "orig.ident", label = "combined_id", n_labels = 30)

```


```{r multi_plates_plot_rle, fig.width = 8, fig.height = 4}
plot_rle(combined_dmso, label_column = "orig.ident", normalisation = "raw") + scale_x_discrete(drop = FALSE) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
plot_rle(combined_dmso, label_column = "orig.ident", normalisation = "edgeR") + scale_x_discrete(drop = FALSE) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r multi_plates_compute_single_de}
treatment_samples <- "Staurosporine_0.1"
control_samples <- "DMSO_0"
subset <- combined[, grepl(paste0(treatment_samples, "|", control_samples), combined$combined_id)]
batch <- subset$orig.ident
combined_edgeR <- compute_single_de(combined, treatment_samples, control_samples, method = "edgeR", batch = batch)
plot_volcano(combined_edgeR)

```

```{r}
genes <- combined_edgeR$gene[1:6]
group_by <- "combined_id"
plot_cpm(combined,genes, group_by, treatment_samples, control_samples)
```


```{r}
summarise_de(combined_edgeR, lfc_threshold = 1, padj_threshold = 0.01, multi=FALSE)
```



```{r}
compute_multi_de_test <- function(data = NULL,
                     treatment_samples = NULL,
                     control_samples = NULL,
                     method = "edgeR",
                     num_cores = 2,
                     batch = 1,
                     k = 2,
                     spikes = NULL) {

  # Helper function to validate input data
  validate_inputs <- function(data, treatment_samples, control_samples, method, num_cores) {
    if (!inherits(data, "Seurat")) {
      stop("Error: argument 'data' must be a Seurat or TidySeurat object.")
    }
    if (!"combined_id" %in% colnames(data@meta.data)) {
      data <- data %>%
        mutate(combined_id = apply(select(starts_with("Treatment_") | starts_with("Concentration_")),
                                   1, paste, collapse = "_")) %>%
        mutate(combined_id = gsub(" ", "", .data$combined_id))
    }
    method <- if (is.null(method)) "edgeR" else method
    if (!method %in% c("Seurat_wilcox", "DESeq2", "edgeR",
                       "RUVg", "RUVs", "RUVr",
                       "limma_voom")) {
      stop("Your normalization method is not available.")
    }
    if (is.null(control_samples)) {
      stop("Missing control samples.")
    }
    if (is.null(treatment_samples)) {
      warn("Missing treatment samples, using all that differ from control.")
      treatment_samples <- data %>%
        select(.data$combined_id) %>%
        filter(!grepl(control_samples, .data$combined_id)) %>%
        pull() %>%
        unique()
    }
    if (length(treatment_samples) == 1 && length(control_samples) == 1) {
      treatment_samples_list <- grepl(treatment_samples, data$combined_id)
      control_samples_list <- grepl(control_samples, data$combined_id)
      if (any(sum(treatment_samples_list) == 0, sum(control_samples_list) == 0)) {
        stop("The combined id of your samples (format: 'treatment'_'concentration') is not valid.")
      }
    }
    num_cores <- if (is.null(num_cores)) (detectCores() - 1) else num_cores
    return(list(data = data, treatment_samples = treatment_samples, num_cores = num_cores))
  }

  validated <- validate_inputs(data, treatment_samples, control_samples, method, num_cores)
  data <- validated$data
  treatment_samples <- validated$treatment_samples
  num_cores <- validated$num_cores

  de_list <- pmclapply(treatment_samples, function(x) {
    if (length(batch) == 1){
      result <- compute_single_de(data, x, control_samples, method, batch, k, spikes)
      result$combined_id <- x
    } else {
      data_subset <- data[, grepl(paste0(x, "|", control_samples), data$combined_id)]
      batch_new <- data_subset$orig.ident
      result <- compute_single_de(data, x, control_samples, method, batch_new, k, spikes)
      result$combined_id <- x
      
    }
    return(result)
  }, mc.cores = num_cores)
  names(de_list) <- treatment_samples
  data@tools[["diff_exprs"]] <- de_list

  return(data)
}
```


```{r}
treatments <- combined %>%
  select(combined_id) %>%
  filter(!grepl("DMSO", combined_id)) %>%
  pull() %>%
  unique()


combined <- compute_multi_de_test(combined, treatments, control_samples = "DMSO_0", method = "edgeR", num_cores = 2, batch = batch)
```

```{r}

summarise_de(combined, lfc_threshold = 1, padj_threshold = 0.01, multi=TRUE)
```

